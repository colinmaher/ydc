head	1.76;
access;
symbols;
locks;
comment	@// @;


1.76
date	2016.06.14.23.34.24;	author -;	state -;
branches;
next	1.75;

1.75
date	2016.06.13.20.55.49;	author -;	state -;
branches;
next	1.74;

1.74
date	2016.03.25.02.30.57;	author -;	state -;
branches;
next	1.73;

1.73
date	2015.07.03.21.46.41;	author -;	state -;
branches;
next	1.72;

1.72
date	2015.07.02.23.48.18;	author -;	state -;
branches;
next	1.71;

1.71
date	2015.07.02.23.03.36;	author -;	state -;
branches;
next	1.70;

1.70
date	2015.07.02.22.52.45;	author -;	state -;
branches;
next	1.69;

1.69
date	2015.07.02.01.52.26;	author -;	state -;
branches;
next	1.68;

1.68
date	2015.07.02.01.47.50;	author -;	state -;
branches;
next	1.67;

1.67
date	2015.07.02.01.40.41;	author -;	state -;
branches;
next	1.66;

1.66
date	2015.07.01.21.16.19;	author -;	state -;
branches;
next	1.65;

1.65
date	2015.07.01.21.05.00;	author -;	state -;
branches;
next	1.64;

1.64
date	2015.07.01.20.34.59;	author -;	state -;
branches;
next	1.63;

1.63
date	2015.07.01.20.16.09;	author -;	state -;
branches;
next	1.62;

1.62
date	2015.07.01.20.12.04;	author -;	state -;
branches;
next	1.61;

1.61
date	2014.06.27.00.06.06;	author -;	state -;
branches;
next	1.60;

1.60
date	2014.06.27.00.02.32;	author -;	state -;
branches;
next	1.59;

1.59
date	2014.06.26.23.51.09;	author -;	state -;
branches;
next	1.58;

1.58
date	2014.06.26.23.20.34;	author -;	state -;
branches;
next	1.57;

1.57
date	2014.06.26.23.18.17;	author -;	state -;
branches;
next	1.56;

1.56
date	2014.06.26.23.14.06;	author -;	state -;
branches;
next	1.55;

1.55
date	2014.04.10.00.03.58;	author -;	state -;
branches;
next	1.54;

1.54
date	2014.04.10.00.02.07;	author -;	state -;
branches;
next	1.53;

1.53
date	2014.04.10.00.00.42;	author -;	state -;
branches;
next	1.52;

1.52
date	2014.04.10.00.00.13;	author -;	state -;
branches;
next	1.51;

1.51
date	2014.04.09.23.49.05;	author -;	state -;
branches;
next	1.50;

1.50
date	2014.04.09.23.48.18;	author -;	state -;
branches;
next	1.49;

1.49
date	2014.04.09.23.47.54;	author -;	state -;
branches;
next	1.48;

1.48
date	2014.04.09.23.46.21;	author -;	state -;
branches;
next	1.47;

1.47
date	2014.04.09.23.43.33;	author -;	state -;
branches;
next	1.46;

1.46
date	2014.04.09.02.15.00;	author -;	state -;
branches;
next	1.45;

1.45
date	2014.04.09.02.14.42;	author -;	state -;
branches;
next	1.44;

1.44
date	2014.04.09.02.08.39;	author -;	state -;
branches;
next	1.43;

1.43
date	2014.04.09.02.04.19;	author -;	state -;
branches;
next	1.42;

1.42
date	2014.04.09.02.04.03;	author -;	state -;
branches;
next	1.41;

1.41
date	2014.04.09.01.43.32;	author -;	state -;
branches;
next	1.40;

1.40
date	2014.04.09.01.36.15;	author -;	state -;
branches;
next	1.39;

1.39
date	2014.04.09.01.17.54;	author -;	state -;
branches;
next	1.38;

1.38
date	2014.04.09.01.06.03;	author -;	state -;
branches;
next	1.37;

1.37
date	2014.04.09.01.04.40;	author -;	state -;
branches;
next	1.36;

1.36
date	2014.04.09.00.52.38;	author -;	state -;
branches;
next	1.35;

1.35
date	2014.04.09.00.51.28;	author -;	state -;
branches;
next	1.34;

1.34
date	2014.04.09.00.49.59;	author -;	state -;
branches;
next	1.33;

1.33
date	2013.08.08.21.48.10;	author -;	state -;
branches;
next	1.32;

1.32
date	2013.07.18.20.10.05;	author -;	state -;
branches;
next	1.31;

1.31
date	2013.07.11.03.13.57;	author -;	state -;
branches;
next	1.30;

1.30
date	2013.07.09.21.48.02;	author -;	state -;
branches;
next	1.29;

1.29
date	2013.07.06.03.18.50;	author -;	state -;
branches;
next	1.28;

1.28
date	2013.06.27.20.10.11;	author -;	state -;
branches;
next	1.27;

1.27
date	2013.06.27.20.09.11;	author -;	state -;
branches;
next	1.26;

1.26
date	2013.06.27.19.39.10;	author -;	state -;
branches;
next	1.25;

1.25
date	2013.06.26.03.33.59;	author -;	state -;
branches;
next	1.24;

1.24
date	2013.06.26.03.33.43;	author -;	state -;
branches;
next	1.23;

1.23
date	2013.06.26.03.31.46;	author -;	state -;
branches;
next	1.22;

1.22
date	2013.06.26.03.31.33;	author -;	state -;
branches;
next	1.21;

1.21
date	2013.06.26.03.30.49;	author -;	state -;
branches;
next	1.20;

1.20
date	2013.06.26.03.30.21;	author -;	state -;
branches;
next	1.19;

1.19
date	2013.06.26.03.29.44;	author -;	state -;
branches;
next	1.18;

1.18
date	2013.06.26.03.28.12;	author -;	state -;
branches;
next	1.17;

1.17
date	2013.06.26.03.27.47;	author -;	state -;
branches;
next	1.16;

1.16
date	2013.06.26.00.23.35;	author -;	state -;
branches;
next	1.15;

1.15
date	2013.06.26.00.23.11;	author -;	state -;
branches;
next	1.14;

1.14
date	2013.06.26.00.22.51;	author -;	state -;
branches;
next	1.13;

1.13
date	2013.06.26.00.22.10;	author -;	state -;
branches;
next	1.12;

1.12
date	2013.06.26.00.21.40;	author -;	state -;
branches;
next	1.11;

1.11
date	2013.06.26.00.21.25;	author -;	state -;
branches;
next	1.10;

1.10
date	2013.06.26.00.18.09;	author -;	state -;
branches;
next	1.9;

1.9
date	2013.06.26.00.17.30;	author -;	state -;
branches;
next	1.8;

1.8
date	2013.06.26.00.16.56;	author -;	state -;
branches;
next	1.7;

1.7
date	2013.06.25.23.54.52;	author -;	state -;
branches;
next	1.6;

1.6
date	2013.06.25.22.19.54;	author -;	state -;
branches;
next	1.5;

1.5
date	2013.06.25.22.19.34;	author -;	state -;
branches;
next	1.4;

1.4
date	2013.06.25.22.18.01;	author -;	state -;
branches;
next	1.3;

1.3
date	2012.04.11.04.02.20;	author -;	state -;
branches;
next	1.2;

1.2
date	2012.04.11.03.43.13;	author -;	state -;
branches;
next	1.1;

1.1
date	2012.04.11.03.42.55;	author -;	state -;
branches;
next	;


desc
@@


1.76
log
@-
@
text
@// $Id: bigint.cpp,v 1.75 2016-06-13 13:55:49-07 - - $

#include <cstdlib>
#include <exception>
#include <stack>
#include <stdexcept>
using namespace std;

#include "bigint.h"
#include "debug.h"
#include "relops.h"

bigint::bigint (long that): uvalue (that), is_negative (that < 0) {
   DEBUGF ('~', this << " -> " << uvalue)
}

bigint::bigint (const ubigint& uvalue, bool is_negative):
                uvalue(uvalue), is_negative(is_negative) {
}

bigint::bigint (const string& that) {
   is_negative = that.size() > 0 and that[0] == '_';
   uvalue = ubigint (that.substr (is_negative ? 1 : 0));
}

bigint bigint::operator+ () const {
   return *this;
}

bigint bigint::operator- () const {
   return {uvalue, not is_negative};
}

bigint bigint::operator+ (const bigint& that) const {
   ubigint result = uvalue + that.uvalue;
   return result;
}

bigint bigint::operator- (const bigint& that) const {
   ubigint result = uvalue - that.uvalue;
   return result;
}

bigint bigint::operator* (const bigint& that) const {
   bigint result = uvalue * that.uvalue;
   return result;
}

bigint bigint::operator/ (const bigint& that) const {
   bigint result = uvalue / that.uvalue;
   return result;
}

bigint bigint::operator% (const bigint& that) const {
   bigint result = uvalue % that.uvalue;
   return result;
}

bool bigint::operator== (const bigint& that) const {
   return is_negative == that.is_negative and uvalue == that.uvalue;
}

bool bigint::operator< (const bigint& that) const {
   if (is_negative != that.is_negative) return is_negative;
   return is_negative ? uvalue > that.uvalue
                      : uvalue < that.uvalue;
}

ostream& operator<< (ostream& out, const bigint& that) {
   return out << "bigint(" << (that.is_negative ? "-" : "+")
              << "," << that.uvalue << ")";
}

@


1.75
log
@-
@
text
@d1 1
a1 1
// $Id: bigint.cpp,v 1.74 2016-03-24 19:30:57-07 - - $
d71 1
a71 1
              << that.uvalue << ")";
@


1.74
log
@-
@
text
@d1 1
a1 1
// $Id: bigint.cpp,v 1.73 2015-07-03 14:46:41-07 - - $
d70 1
a70 1
   return out << "bigint(" << (that.is_negative ? "'-'" : "'+'")
@


1.73
log
@-
@
text
@d1 1
a1 1
// $Id: bigint.cpp,v 1.72 2015-07-02 16:48:18-07 - - $
d26 1
a26 1
bigint bigint::operator+() const {
d30 1
a30 1
bigint bigint::operator-() const {
a48 1

@


1.72
log
@-
@
text
@d1 1
a1 1
// $Id: bigint.cpp,v 1.71 2015-07-02 16:03:36-07 - - $
d11 1
d13 1
a13 1
bigint::bigint (long that): uvalue (that) {
d65 3
a67 9
   return uvalue < that.uvalue;
}

bigint::operator long() const {
   if (*this <= bigint (numeric_limits<long>::min())
    or *this > bigint (numeric_limits<long>::max()))
               throw range_error ("bigint::long(): out of range");
   long value = uvalue;
   return is_negative ? -value : value;
d71 2
a72 2
   out << that.uvalue;
   return out;
@


1.71
log
@-
@
text
@d1 1
a1 1
// $Id: bigint.cpp,v 1.70 2015-07-02 15:52:45-07 - - $
d21 2
a22 10
   auto itor = that.cbegin();
   bool isnegative = false;
   if (itor != that.cend() and *itor == '_') {
      isnegative = true;
      ++itor;
   }
   int newval = 0;
   while (itor != that.end()) newval = newval * 10 + *itor++ - '0';
   uvalue = isnegative ? - newval : + newval;
   DEBUGF ('~', this << " -> " << uvalue)
d70 3
a72 2
               throw range_error ("bigint_to_long: out of range");
   return 0;
@


1.70
log
@-
@
text
@d1 1
a1 1
// $Id: bigint.cpp,v 1.69 2015-07-01 18:52:26-07 - - $
d75 1
a75 1
long bigint::to_long() const {
@


1.69
log
@-
@
text
@d1 1
a1 1
// $Id: bigint.cpp,v 1.68 2015-07-01 18:47:50-07 - - $
a86 22
bigint pow (const bigint& base, const bigint& exponent) {
   DEBUGF ('^', "base = " << base << ", exponent = " << exponent);
   if (base == 0) return 0;
   bigint base_copy = base;
   long expt = exponent.to_long();
   bigint result = 1;
   if (expt < 0) {
      base_copy = bigint (1) / base_copy;
      expt = - expt;
   }
   while (expt > 0) {
      if (expt & 1) { //odd
         result = result * base_copy;
         --expt;
      }else { //even
         base_copy = base_copy * base_copy;
         expt /= 2;
      }
   }
   DEBUGF ('^', "result = " << result);
   return result;
}
@


1.68
log
@-
@
text
@d1 1
a1 1
// $Id: bigint.cpp,v 1.67 2015-07-01 18:40:41-07 - - $
d56 1
@


1.67
log
@-
@
text
@d1 1
a1 1
// $Id: bigint.cpp,v 1.66 2015-07-01 14:16:19-07 - - $
d33 1
a33 1
bigint operator+() {
d37 2
a38 4
bigint operator-() {
   ubigint result = *this;
   result.is_negative = not result.is_negative;
   return result;
d41 1
a41 1
bigint operator+ (const bigint& that) {
d46 1
a46 1
bigint operator- (const bigint& that) {
d51 1
a51 8
long bigint::to_long() const {
   if (*this <= bigint (numeric_limits<long>::min())
    or *this > bigint (numeric_limits<long>::max()))
               throw range_error ("bigint_to_long: out of range");
   return 0;
}

bigint operator* (const bigint& that) {
d56 1
a56 1
bigint operator/ (const bigint& that) {
d61 1
a61 1
bigint operator% (const bigint& that) {
d66 1
a66 1
bool operator== (const bigint& that) {
d70 1
a70 1
bool operator< (const bigint& that) {
d74 7
d93 1
a93 1
      base_copy = 1 / base_copy;
@


1.66
log
@-
@
text
@d1 1
a1 1
// $Id: bigint.cpp,v 1.65 2015-07-01 14:05:00-07 - - $
d33 2
a34 4

bigint operator+ (const bigint& left, const bigint& right) {
   ubigint uvalue = left.uvalue + right.uvalue;
   return uvalue;
d37 4
a40 3
bigint operator- (const bigint& left, const bigint& right) {
   ubigint uvalue = left.uvalue - right.uvalue;
   return uvalue;
d43 3
a45 2
bigint operator+ (const bigint& right) {
   return right;
d48 2
a49 3
bigint operator- (const bigint& right) {
   bigint result = right;
   result.is_negative = not result.is_negative;
d60 2
a61 2
bigint operator* (const bigint& left, const bigint& right) {
   bigint result = left.uvalue * right.uvalue;
d65 2
a66 2
bigint operator/ (const bigint& left, const bigint& right) {
   bigint result = left.uvalue / right.uvalue;
d70 2
a71 2
bigint operator% (const bigint& left, const bigint& right) {
   bigint result = left.uvalue % right.uvalue;
d75 2
a76 3
bool operator== (const bigint& left, const bigint& right) {
   return left.is_negative == right.is_negative
      and left.uvalue == right.uvalue;
d79 2
a80 2
bool operator< (const bigint& left, const bigint& right) {
   return left.uvalue < right.uvalue;
a87 1

@


1.65
log
@-
@
text
@d1 1
a1 1
// $Id: bigint.cpp,v 1.64 2015-07-01 13:34:59-07 - - $
d16 4
d35 2
a36 1
   return left.uvalue + right.uvalue;
d40 2
a41 1
   return left.uvalue - right.uvalue;
d45 1
a45 1
   return +right.uvalue;
d49 3
a51 1
   return -right.uvalue;
d58 1
a58 1
   return uvalue;
a60 7
bool abs_less (const long& left, const long& right) {
   return left < right;
}

//
// Multiplication algorithm.
//
d62 2
a63 1
   return left.uvalue * right.uvalue;
a65 4
//
// Division algorithm.
//

d67 2
a68 1
   return left.uvalue / right.uvalue;
d72 2
a73 1
   return left.uvalue % right.uvalue;
d77 2
a78 1
   return left.uvalue == right.uvalue;
@


1.64
log
@-
@
text
@d1 1
a1 1
// $Id: bigint.cpp,v 1.63 2015-07-01 13:16:09-07 - - $
d12 2
a13 2
bigint::bigint (long that): long_value (that) {
   DEBUGF ('~', this << " -> " << long_value)
d25 2
a26 2
   long_value = isnegative ? - newval : + newval;
   DEBUGF ('~', this << " -> " << long_value)
d31 1
a31 1
   return left.long_value + right.long_value;
d35 1
a35 1
   return left.long_value - right.long_value;
d39 1
a39 1
   return +right.long_value;
d43 1
a43 1
   return -right.long_value;
d50 1
a50 1
   return long_value;
d61 1
a61 1
   return left.long_value * right.long_value;
a67 33
void multiply_by_2 (bigint::unumber& unumber_value) {
   unumber_value *= 2;
}

void divide_by_2 (bigint::unumber& unumber_value) {
   unumber_value /= 2;
}


bigint::quot_rem divide (const bigint& left, const bigint& right) {
   if (right == 0) throw domain_error ("divide by 0");
   using unumber = unsigned long;
   static unumber zero = 0;
   if (right == 0) throw domain_error ("bigint::divide");
   unumber divisor = right.long_value;
   unumber quotient = 0;
   unumber remainder = left.long_value;
   unumber power_of_2 = 1;
   while (abs_less (divisor, remainder)) {
      multiply_by_2 (divisor);
      multiply_by_2 (power_of_2);
   }
   while (abs_less (zero, power_of_2)) {
      if (not abs_less (remainder, divisor)) {
         remainder = remainder - divisor;
         quotient = quotient + power_of_2;
      }
      divide_by_2 (divisor);
      divide_by_2 (power_of_2);
   }
   return {quotient, remainder};
}

d69 1
a69 1
   return divide (left, right).first;
d73 1
a73 1
   return divide (left, right).second;
d77 1
a77 1
   return left.long_value == right.long_value;
d81 1
a81 1
   return left.long_value < right.long_value;
d85 1
a85 1
   out << that.long_value;
@


1.63
log
@-
@
text
@d1 1
a1 1
// $Id: bigint.cpp,v 1.62 2015-07-01 13:12:04-07 - - $
d12 2
a13 2
bigint::bigint (long that): int64_value (that) {
   DEBUGF ('~', this << " -> " << int64_value)
d25 2
a26 2
   int64_value = isnegative ? - newval : + newval;
   DEBUGF ('~', this << " -> " << int64_value)
d31 1
a31 1
   return left.int64_value + right.int64_value;
d35 1
a35 1
   return left.int64_value - right.int64_value;
d39 1
a39 1
   return +right.int64_value;
d43 1
a43 1
   return -right.int64_value;
d46 1
a46 1
long bigint::to_int64() const {
d49 2
a50 2
               throw range_error ("bigint_to_int64: out of range");
   return int64_value;
d61 1
a61 1
   return left.int64_value * right.int64_value;
d82 1
a82 1
   unumber divisor = right.int64_value;
d84 1
a84 1
   unumber remainder = left.int64_value;
d110 1
a110 1
   return left.int64_value == right.int64_value;
d114 1
a114 1
   return left.int64_value < right.int64_value;
d118 1
a118 1
   out << that.int64_value;
d127 1
a127 1
   long expt = exponent.to_int64();
@


1.62
log
@-
@
text
@d1 1
a1 1
// $Id: bigint.cpp,v 1.61 2014-06-26 17:06:06-07 - - $
d12 1
a12 1
bigint::bigint (int64_t that): int64_value (that) {
d46 3
a48 3
int64_t bigint::to_int64() const {
   if (*this <= bigint (numeric_limits<int64_t>::min())
    or *this > bigint (numeric_limits<int64_t>::max()))
d53 1
a53 1
bool abs_less (const int64_t& left, const int64_t& right) {
d79 1
a79 1
   using unumber = uint64_t;
d127 1
a127 1
   int64_t expt = exponent.to_int64();
@


1.61
log
@-
@
text
@d1 1
a1 1
// $Id: bigint.cpp,v 1.59 2014-06-26 16:51:09-07 - - $
a4 1
#include <limits>
d12 2
a13 2
bigint::bigint (long that): long_value (that) {
   DEBUGF ('~', this << " -> " << long_value)
d25 2
a26 2
   long_value = isnegative ? - newval : + newval;
   DEBUGF ('~', this << " -> " << long_value)
d31 1
a31 1
   return left.long_value + right.long_value;
d35 1
a35 1
   return left.long_value - right.long_value;
d39 1
a39 1
   return +right.long_value;
d43 1
a43 1
   return -right.long_value;
d46 5
a50 5
long bigint::to_long() const {
   if (*this <= bigint (numeric_limits<long>::min())
    or *this > bigint (numeric_limits<long>::max()))
               throw range_error ("bigint__to_long: out of range");
   return long_value;
d53 1
a53 1
bool abs_less (const long& left, const long& right) {
d61 1
a61 1
   return left.long_value * right.long_value;
d79 1
a79 1
   using unumber = unsigned long;
d82 1
a82 1
   unumber divisor = right.long_value;
d84 1
a84 1
   unumber remainder = left.long_value;
d110 1
a110 1
   return left.long_value == right.long_value;
d114 1
a114 1
   return left.long_value < right.long_value;
d118 1
a118 1
   out << that.long_value;
d127 1
a127 1
   long expt = exponent.to_long();
@


1.60
log
@-
@
text
@d14 1
@


1.59
log
@-
@
text
@d1 1
a1 1
// $Id: bigint.cpp,v 1.57 2014-06-26 16:18:17-07 - - $
a12 21
#define CDTOR_TRACE DEBUGF ('~', this << " -> " << long_value)

bigint::bigint(): long_value (0) {
   CDTOR_TRACE;
}

bigint::bigint (const bigint& that): long_value (that.long_value) {
   *this = that;
   CDTOR_TRACE;
}

bigint& bigint::operator= (const bigint& that) {
   if (this == &that) return *this;
   this->long_value = that.long_value;
   return *this;
}

bigint::~bigint() {
   CDTOR_TRACE;
}

a13 1
   CDTOR_TRACE;
d26 1
a26 1
   CDTOR_TRACE;
@


1.58
log
@-
@
text
@a2 1
#include <cassert>
a38 1
   assert (that.size() > 0);
d41 4
a44 1
   if (*itor == '_') {isnegative = true; ++itor; }
d61 1
a61 1
   return right.long_value;
d68 1
a68 1
long bigint::long() const {
d71 1
a71 1
               throw range_error ("to_long: out of range");
d83 1
a83 1
   return long_value * right.long_value;
d90 2
a91 2
void mul_by_2 (long& long_value) {
   long_value *= 2;
d94 2
a95 2
void div_by_2 (long& long_value) {
   long_value /= 2;
d99 2
a100 2
bigint::quotient_remainder bigint::divide (const bigint& that) const {
   if (that == 0) throw domain_error ("divide by 0");
d103 1
a103 1
   if (that == 0) throw domain_error ("bigint::divide");
d109 2
a110 2
      mul_by_2 (divisor);
      mul_by_2 (power_of_2);
d117 2
a118 2
      div_by_2 (divisor);
      div_by_2 (power_of_2);
d124 1
a124 1
   return divide (that).first;
d128 1
a128 1
   return divide (that).second;
@


1.57
log
@-
@
text
@d1 1
a1 1
// $Id: bigint.cpp,v 1.56 2014-06-26 16:14:06-07 - - $
d27 1
a27 1
   left.long_value = right.long_value;
d67 1
a67 1
long bigint::to_long() const {
@


1.56
log
@-
@
text
@d1 1
a1 1
// $Id: bigint.cpp,v 1.55 2014-04-09 17:03:58-07 - - $
d27 1
a27 1
   this->long_value = that.long_value;
d51 2
a52 2
bigint bigint::operator+ (const bigint& that) const {
   return this->long_value + that.long_value;
d55 2
a56 2
bigint bigint::operator- (const bigint& that) const {
   return this->long_value - that.long_value;
d59 6
a64 2
bigint bigint::operator-() const {
   return -long_value;
d81 2
a82 2
bigint bigint::operator* (const bigint& that) const {
   return long_value * that.long_value;
d103 1
a103 1
   unumber divisor = that.long_value;
d105 1
a105 1
   unumber remainder = this->long_value;
d122 1
a122 1
bigint bigint::operator/ (const bigint& that) const {
d126 1
a126 1
bigint bigint::operator% (const bigint& that) const {
d130 2
a131 2
bool bigint::operator== (const bigint& that) const {
   return this->long_value == that.long_value;
d134 2
a135 2
bool bigint::operator< (const bigint& that) const {
   return this->long_value < that.long_value;
@


1.55
log
@-
@
text
@d1 1
a1 1
// $Id: bigint.cpp,v 1.51 2014-04-09 16:49:05-07 - - $
d96 1
a96 1
   typedef long unumber;
@


1.54
log
@-
@
text
@d41 1
a41 1
   const auto itor = that.cbegin();
@


1.53
log
@-
@
text
@d41 1
a41 1
   auto const& itor = that.cbegin();
@


1.52
log
@-
@
text
@d41 1
a41 1
   auto& itor = that.cbegin();
@


1.51
log
@-
@
text
@d1 1
a1 1
// $Id: bigint.cpp,v 1.50 2014-04-09 16:48:18-07 - - $
d41 1
a41 1
   const auto& itor = that.cbegin();
@


1.50
log
@-
@
text
@d1 1
a1 1
// $Id: bigint.cpp,v 1.49 2014-04-09 16:47:54-07 - - $
d41 1
a41 1
   auto& itor = that.cbegin();
@


1.49
log
@-
@
text
@d1 1
a1 1
// $Id: bigint.cpp,v 1.47 2014-04-09 16:43:33-07 - - $
d41 1
a41 1
   const auto& itor = that.cbegin();
@


1.48
log
@-
@
text
@d41 1
a41 1
   string::const_iterator itor = that.cbegin();
d45 1
a45 1
   for (; itor != that.end(); ++itor) newval = newval * 10 + *itor - '0';
@


1.47
log
@-
@
text
@d1 1
a1 1
// $Id: bigint.cpp,v 1.46 2014-04-08 19:15:00-07 - - $
d41 1
a41 1
   string::const_iterator itor = that.begin();
@


1.46
log
@-
@
text
@d1 1
a1 1
// $Id: bigint.cpp,v 1.45 2014-04-08 19:14:42-07 - - $
d40 1
a41 1
   const string::const_iterator end = that.end();
d45 1
a45 1
   for (; itor != end; ++itor) newval = newval * 10 + *itor - '0';
@


1.45
log
@-
@
text
@d1 1
a1 1
// $Id: bigint.cpp,v 1.44 2014-04-08 19:08:39-07 - - $
d94 1
a94 1
quotient_remainder bigint::divide (const bigint& that) const {
@


1.44
log
@-
@
text
@d1 1
a1 1
// $Id: bigint.cpp,v 1.43 2014-04-08 19:04:19-07 - - $
d94 1
a94 1
quo_rem bigint::divide (const bigint& that) const {
d119 1
a119 1
   return divide (that).quotient;
d123 1
a123 1
   return divide (that).remainder;
@


1.43
log
@-
@
text
@d1 1
a1 1
// $Id: bigint.cpp,v 1.42 2014-04-08 19:04:03-07 - - $
d94 1
a94 1
bigint bigint::divide (const bigint& that, const div_rem_op op) const {
d115 1
a115 6
   switch (op) {
      case QUOTIENT: return quotient;
      case REMAINDER: return remainder;
   }
   assert (false and "Not possible to get here.");
   return 0;
d119 1
a119 1
   return divide (that, QUOTIENT);
d123 1
a123 1
   return divide (that, REMAINDER);
@


1.42
log
@-
@
text
@d1 1
a1 1
// $Id: bigint.cpp,v 1.41 2014-04-08 18:43:32-07 - - $
d3 1
@


1.41
log
@-
@
text
@d1 1
a1 1
// $Id: bigint.cpp,v 1.40 2014-04-08 18:36:15-07 - - $
d118 2
@


1.40
log
@-
@
text
@d1 1
a1 1
// $Id: bigint.cpp,v 1.39 2014-04-08 18:17:54-07 - - $
d15 1
a15 1
bigint::bigint (): long_value (0) {
d58 1
a58 1
bigint bigint::operator- () const {
d62 1
a62 1
long bigint::to_long () const {
@


1.39
log
@-
@
text
@d1 1
a1 1
// $Id: bigint.cpp,v 1.38 2014-04-08 18:06:03-07 - - $
a7 1

@


1.38
log
@-
@
text
@d1 1
a1 1
// $Id: bigint.cpp,v 1.37 2014-04-08 18:04:40-07 - - $
d64 2
a65 2
   if (*this <= numeric_limits<long>::min()
    or *this > numeric_limits<long>::max())
@


1.37
log
@-
@
text
@d1 1
a1 1
// $Id: bigint.cpp,v 1.36 2014-04-08 17:52:38-07 - - $
d65 1
a65 1
    || *this > numeric_limits<long>::max())
@


1.36
log
@-
@
text
@d1 1
a1 1
// $Id: bigint.cpp,v 1.35 2014-04-08 17:51:28-07 - - $
d20 1
a20 1
bigint::bigint (const bigint &that): long_value (that.long_value) {
d25 1
a25 1
bigint &bigint::operator= (const bigint &that) {
d39 1
a39 1
bigint::bigint (const string &that) {
d51 1
a51 1
bigint bigint::operator+ (const bigint &that) const {
d55 1
a55 1
bigint bigint::operator- (const bigint &that) const {
d70 1
a70 1
bool abs_less (const long &left, const long &right) {
d77 1
a77 1
bigint bigint::operator* (const bigint &that) const {
d85 1
a85 1
void mul_by_2 (long &long_value) {
d89 1
a89 1
void div_by_2 (long &long_value) {
d94 1
a94 1
bigint bigint::divide (const bigint &that, const div_rem_op op) const {
d121 1
a121 1
bigint bigint::operator/ (const bigint &that) const {
d125 1
a125 1
bigint bigint::operator% (const bigint &that) const {
d129 1
a129 1
bool bigint::operator== (const bigint &that) const {
d133 1
a133 1
bool bigint::operator< (const bigint &that) const {
d137 1
a137 1
ostream &operator<< (ostream &out, const bigint &that) {
d143 1
a143 1
bigint pow (const bigint &base, const bigint &exponent) {
@


1.35
log
@-
@
text
@d1 1
a1 1
// $Id: bigint.cpp,v 1.34 2014-04-08 17:49:59-07 - - $
d144 1
a144 1
   TRACE ('^', "base = " << base << ", exponent = " << exponent);
d162 1
a162 1
   TRACE ('^', "result = " << result);
@


1.34
log
@-
@
text
@d1 1
a1 1
// $Id: bigint.cpp,v 1.33 2013-08-08 14:48:10-07 - - $
d14 1
a14 1
#define CDTOR_TRACE TRACE ('~', this << " -> " << long_value)
@


1.33
log
@-
@
text
@d1 1
a1 1
// $Id: bigint.cpp,v 1.32 2013-07-18 13:10:05-07 - - $
d12 1
a12 1
#include "trace.h"
@


1.32
log
@-
@
text
@d1 1
a1 1
// $Id: bigint.cpp,v 1.31 2013-07-10 20:13:57-07 - - $
d108 1
a108 1
      if (! abs_less (remainder, divisor)) {
@


1.31
log
@-
@
text
@d1 1
a1 1
// $Id: bigint.cpp,v 1.30 2013-07-09 14:48:02-07 - - $
d98 1
a98 1
   if (that == 0) throw domain_error ("unumber::divide");
@


1.30
log
@-
@
text
@d1 1
a1 1
// $Id: bigint.cpp,v 1.29 2013-07-05 20:18:50-07 - - $
d145 1
@


1.29
log
@-
@
text
@d1 1
a1 1
// $Id: bigint.cpp,v 1.28 2013-06-27 13:10:11-07 - - $
d41 1
a41 1
   string::const_iterator end = that.end();
@


1.28
log
@-
@
text
@d1 1
a1 1
// $Id: bigint.cpp,v 1.27 2013-06-27 13:09:11-07 - - $
d50 1
d93 1
d142 1
@


1.27
log
@-
@
text
@d1 1
a1 1
// $Id: bigint.cpp,v 1.26 2013-06-27 12:39:10-07 - - $
d69 1
a69 1
bool bigint::abs_less (const long &left, const long &right) {
d84 1
a84 1
void bigint::mul_by_2 (long &long_value) {
d88 1
a88 1
void bigint::div_by_2 (long &long_value) {
@


1.26
log
@-
@
text
@d1 1
a1 1
// $Id: bigint.cpp,v 1.25 2013-06-25 20:33:59-07 - - $
a68 8
void bigint::mul_by_2 () {
   this->long_value *= 2;
}

void bigint::div_by_2 () {
   this->long_value /= 2;
}

d83 9
d102 2
a103 2
      divisor *= 2;
      power_of_2 *= 2;
d106 1
a106 1
      if (divisor <= remainder) {
d110 2
a111 2
      divisor /= 2;
      power_of_2 /= 2;
@


1.25
log
@-
@
text
@d1 1
a1 1
// $Id: bigint.cpp,v 1.24 2013-06-25 20:33:43-07 - - $
a138 1

@


1.24
log
@-
@
text
@d1 1
a1 1
// $Id: bigint.cpp,v 1.23 2013-06-25 20:31:46-07 - - $
d77 1
a77 1
static bool bigint::abs_less (const long &left, const long &right) {
@


1.23
log
@-
@
text
@d1 1
a1 1
// $Id: bigint.cpp,v 1.22 2013-06-25 20:31:33-07 - - $
d77 1
a77 1
static bool abs_less (const long &left, const long &right) {
@


1.22
log
@-
@
text
@d1 1
a1 1
// $Id: bigint.cpp,v 1.21 2013-06-25 20:30:49-07 - - $
d104 1
a104 1
   while (abs_less (zero, power_of_2) {
@


1.21
log
@-
@
text
@d1 1
a1 1
// $Id: bigint.cpp,v 1.20 2013-06-25 20:30:21-07 - - $
d101 2
a102 2
      divisor.mul_by_2()
      power_of_2.mul_by_2()
d109 2
a110 2
      divisor.div_by_2();
      power_of_2.div_by_2();
@


1.20
log
@-
@
text
@d1 1
a1 1
// $Id: bigint.cpp,v 1.19 2013-06-25 20:29:44-07 - - $
d77 1
a77 1
static bool abs_less (const long &left, const long &right) const {
@


1.19
log
@-
@
text
@d1 1
a1 1
// $Id: bigint.cpp,v 1.18 2013-06-25 20:28:12-07 - - $
d77 1
a77 2
static bool abs_less (const long_value &left,
                      const long_value &right) const {
@


1.18
log
@-
@
text
@d1 1
a1 1
// $Id: bigint.cpp,v 1.17 2013-06-25 20:27:47-07 - - $
a61 4
bool bigint::abs_less (const bigint &that) const {
   return long_value < that.long_value;
}

d77 2
a78 2
static bool abs_less (const long_value left,
                      const long_value right) const {
@


1.17
log
@-
@
text
@d1 1
a1 1
// $Id: bigint.cpp,v 1.16 2013-06-25 17:23:35-07 - - $
d77 1
a77 1
void bigint::mul_by_2 () {
@


1.16
log
@-
@
text
@d1 1
a1 1
// $Id: bigint.cpp,v 1.15 2013-06-25 17:23:11-07 - - $
d77 9
d105 3
a107 3
   while (divisor < remainder) {
      divisor *= 2;
      power_of_2 *= 2;
d109 1
a109 1
   while (power_of_2 > zero) {
d114 2
a115 2
      divisor /= 2;
      power_of_2 /= 2;
@


1.15
log
@-
@
text
@d1 1
a1 1
// $Id: bigint.cpp,v 1.14 2013-06-25 17:22:51-07 - - $
d115 1
a115 1
   return div_rem (that).first;
d119 1
a119 1
   return div_rem (that).second;
@


1.14
log
@-
@
text
@d1 1
a1 1
// $Id: bigint.cpp,v 1.13 2013-06-25 17:22:10-07 - - $
d108 1
a108 1
   switch (div_rem) {
@


1.13
log
@-
@
text
@d1 1
a1 1
// $Id: bigint.cpp,v 1.12 2013-06-25 17:21:40-07 - - $
d97 2
a98 2
      divisor.mul_by_2();
      power_of_2.mul_by_2();
d105 2
a106 2
      divisor.div_by_2();
      power_of_2.div_by_2();
@


1.12
log
@-
@
text
@d1 1
a1 1
// $Id: bigint.cpp,v 1.11 2013-06-25 17:21:25-07 - - $
d91 1
a91 1
   if (that == 0) throw zero_divide ("unumber::divide");
@


1.11
log
@-
@
text
@d1 1
a1 1
// $Id: bigint.cpp,v 1.10 2013-06-25 17:18:09-07 - - $
d89 1
a89 1
   typedef unumber long;
@


1.10
log
@-
@
text
@d1 1
a1 1
// $Id: bigint.cpp,v 1.9 2013-06-25 17:17:30-07 - - $
d14 1
a14 1
#define CDTOR_TRACE TRACE ('~', this << " -> " << small_value)
d16 1
a16 1
bigint::bigint (): small_value (0) {
d20 1
a20 1
bigint::bigint (const bigint &that): small_value (that.small_value) {
d27 1
a27 1
   this->small_value = that.small_value;
d35 1
a35 1
bigint::bigint (long that): small_value (that) {
d46 1
a46 1
   small_value = isnegative ? - newval : + newval;
d51 1
a51 1
   return this->small_value + that.small_value;
d55 1
a55 1
   return this->small_value - that.small_value;
d59 1
a59 1
   return -small_value;
d63 1
a63 1
   return small_value < that.small_value;
d70 1
a70 1
   return small_value;
d74 1
a74 1
   this->small_value *= 2;
d81 1
a81 1
   return small_value * that.small_value;
d89 1
d92 1
a92 1
   unumber divisor = that;
d94 1
a94 1
   unumber remainder = *this;
d123 1
a123 1
   return this->small_value == that.small_value;
d127 1
a127 1
   return this->small_value < that.small_value;
d131 1
a131 1
   out << that.small_value;
@


1.9
log
@-
@
text
@d1 1
a1 1
// $Id: bigint.cpp,v 1.7 2013-06-25 16:54:52-07 - - $
d81 1
a81 2
   bigint result = 0;
   return result;
@


1.8
log
@-
@
text
@d73 2
a74 2
bigint bigint::mul_by_2 () {
   return this->small_value *= 2;
@


1.7
log
@-
@
text
@d1 1
a1 1
// $Id: bigint.cpp,v 1.6 2013-06-25 15:19:54-07 - - $
d35 1
a35 1
bigint::bigint (int that): small_value (that) {
d62 2
a63 3
int bigint::abscompare (const bigint &that) const {
   return abs (this->small_value) < abs (that.small_value) ? -1
        : abs (this->small_value) > abs (that.small_value) ? +1 : 0;
d66 4
a69 4
int bigint::smallint () const {
   if (*this < numeric_limits<int>::min()
    || *this > numeric_limits<int>::max())
               throw range_error ("smallint: out of range");
a76 6
static bigpair popstack (stack <bigpair> &egyptstack) {
   bigpair result = egyptstack.top ();
   egyptstack.pop();
   return result;
}

a80 8
   bigint top = that;
   bigint count = 1;
   TRACE ('*', *this << " * " << that);
   stack <bigpair> egyptstack;
   bigint a; // junk code -- delete
   bigint b; // junk code -- delete
   egyptstack.push (pair<bigint, bigint> (a, b)); // junk code -- delete
   popstack (egyptstack); // junk to suppress a warning
a81 1
   if ((*this < 0) != (that < 0)) result = - result;
d88 24
a111 9
bigpair bigint::divide (const bigint &that) const {
   if (that == 0) throw range_error ("divide by 0");
   bigint count = 1;
   bigint top = abs (that.small_value);
   TRACE ('/', *this << " /% " << that);
   stack <bigpair> egyptstack;
   bigint quotient = 0;
   bigint remainder = abs (this->small_value);
   return bigpair (quotient, remainder);
d122 1
a122 1
bool bigint::operator == (const bigint &that) const {
d126 1
a126 1
bool bigint::operator < (const bigint &that) const {
a129 12
#define INT_LEFT(RESULT,OPER) \
   RESULT operator OPER (const int left, const bigint &right) { \
      return bigint (left) OPER right; \
   }
INT_LEFT (bigint, +)
INT_LEFT (bigint, -)
INT_LEFT (bigint, *)
INT_LEFT (bigint, /)
INT_LEFT (bigint, %)
INT_LEFT (bool, ==)
INT_LEFT (bool, !=)

a135 2
#define TRACE_POW TRACE ('^', "result: " << result \
                  << ", base: " << base_copy << ", expt: " << expt);
d137 1
d139 1
a139 2
   if (exponent > 999) throw range_error ("exp too big");
   int expt = exponent.smallint();
a140 1
   TRACE_POW;
a145 1
      TRACE_POW;
d154 1
a154 1
   TRACE_POW;
@


1.6
log
@-
@
text
@d1 1
a1 1
// $Id: bigint.cpp,v 1.5 2013-06-25 15:19:34-07 - - $
a49 1

a83 1

d85 1
a85 1
// Ancient Egyptian multiplication algorithm.
d102 1
a102 1
// Ancient Egyptian division algorithm.
d104 1
a104 1
bigpair bigint::div_rem (const bigint &that) const {
@


1.5
log
@-
@
text
@d1 1
a1 1
// $Id: bigint.cpp,v 1.4 2013-06-25 15:18:01-07 - - $
d130 1
a130 1
   this->small_value < that.small_value;
@


1.4
log
@-
@
text
@d1 1
a1 1
// $Id: bigint.cpp,v 1.3 2012-04-10 21:02:20-07 - - $
a62 5
int bigint::compare (const bigint &that) const {
   return this->small_value < that.small_value ? -1
        : this->small_value > that.small_value ? +1 : 0;
}

d134 2
a135 2
   RESULT operator OPER (int left, const bigint &that) { \
      return bigint (left) OPER that; \
@


1.3
log
@-
@
text
@d1 1
a1 1
// $Id: bigint.cpp,v 1.2 2012-04-10 20:43:13-07 - - $
d130 2
a131 25

#define TRACE_POW TRACE ('^', "result: " << result \
                  << ", base: " << base << ", expt: " << expt);
bigint bigint::pow (const bigint &that) const {
   bigint base = *this;
   if (that > 999) throw range_error ("exp too big");
   int expt = that.smallint();
   bigint result = 1;
   TRACE_POW;
   if (expt < 0) {
      base = 1 / base;
      expt = - expt;
   }
   while (expt > 0) {
      TRACE_POW;
      if (expt & 1) { //odd
         result = result * base;
         --expt;
      }else { //even
         base = base * base;
         expt /= 2;
      }
   }
   TRACE_POW;
   return result;
d134 3
a136 14
//
// Macros can make repetitive code easier.
//

#define COMPARE(OPER) \
   bool bigint::operator OPER (const bigint &that) const { \
      return compare (that) OPER 0; \
   }
COMPARE (==)
COMPARE (!=)
COMPARE (< )
COMPARE (<=)
COMPARE (> )
COMPARE (>=)
a148 4
INT_LEFT (bool, < )
INT_LEFT (bool, <=)
INT_LEFT (bool, > )
INT_LEFT (bool, >=)
d155 26
@


1.2
log
@-
@
text
@d1 1
a1 1
// $Id: bigint.cpp,v 1.1 2012-04-10 20:42:55-07 - - $
d50 1
d90 1
d130 3
a132 3
#define TRACE_POW \
   TRACE ('^', "result: " << result << ", base: " << base \
            << ", expt: " << expt);
@


1.1
log
@-
@
text
@d1 1
a1 1
// $Id: bigint.cc,v 1.12 2011-01-26 14:41:21-08 - - $
d7 1
@
